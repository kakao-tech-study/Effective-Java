### 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.

**예외의 구조(계층) - 미리 알고가기**

자바에서 모든 예외의 최상위 클래스는 Throwable이다.

그리고, 이 클래스는 두가지 하위 클래스, Error와 Exception으로 나뉘며 Error는 JVM에서 발생하는 심각한 문제이고 Exception은 애플리케이션 코드에서 잡아 처리할 수 있는 문제이다.

여기서 Exception은 또다시, 검사예외(Checked Exception) 과 비검사예외(Unchecked Exception, RuntimeException을 상속받은 예외) 로 나뉘게 된다.

| 예외 종류    | 검사 예외                                                | 비검사 예외                                              |
|----------|------------------------------------------------------|-----------------------------------------------------|
| 예외 처리 강제 | O(try-catch/throws 필수)                               | X                                                   |
| 예시       | IOException, SQLException 등                          | IllegalArgumentException, NullPointerException 등    |
| 사용하는 경우  | 호출한 쪽에서 복구 가능성이 있는 경우나 파일 입출력/네트워크 통신 등 외부 환경에 의존할 때 | 프로그래머 실수로 발생하는 경우나 복구 가능성이 낮은 경우, 메서드 사용 계약을 위반한 경우 |

검사예외와 비검사예외(런타임예외)를 사용할 때의 기준을 “호출하는 쪽에서 복구하리라 여겨지는 상황” 으로 잡으며, 기본적인 규칙이다.

검사 예외를 던지면 호출자가 그 예외를 잡아 처리하거나 바깥으로 전파하도록 강제하게 되며, 이를 통해 API 사용자에게 알려줄 수 있다.

그러면 여기서 복구한다는 말의 의미는 무엇일까?

사용자에게 알리고, 대체 동작을 하거나, 재시도 하거나 안전하게 종료하는 등 프로그램을 이어갈 수 있도록 하는 방법이 존재할 때, 이를 수행하는것을 말한다.

그래도 잘 이해가 안가는데,,? 라는 생각으로 예시를 좀 더 알아보고 생각을 해보았다.

```
// 파일이 없을 경우 대체 동작을 통해 동작을 이어 진행하기
try {
    readConfigFile("config.txt");
} catch (FileNotFoundException e) {
    System.out.println("기본 설정을 사용합니다.");
    useDefaultConfig();
}

// 잘못된 값으로 인한 오류이며, 이런 것들은 복구가 아닌 코드 자체를 수정해야 한다.
public void setAge(int age) {
    if (age < 0) {
        throw new IllegalArgumentException("나이는 음수가 될 수 없습니다.");
    }
}

```

이 예시를 바탕으로 한번 더 생각해 보았다.

내가 흔히 접하는 경우는 어떤 경우일까?

대부분은 프로그래머나 API 호출자의 잘못된 호출로 인해 발생하는 복구 불가능한 오류이며, 파일을 읽고 쓸때나 가끔 복구할 수 있는 상황(파일을 쓰려고 할때, 없으면 파일을 만든 후에 쓰는 등) 이 있다는 생각이
들었다.

이처럼, 검사예외는 일반적으로 복구할 수 있는 조건(지속할 수 있는 상황)에서 발생한다.

따라서 호출자가 예외 상황에서 벗어나기 위해(함수를 지속적으로 수행하기 위해) 필요한 메서드를 함께 제공해주는 것이 중요하며, 위 함수에서는 useDefaultConfig() 가 이에 해당한다.

그런데 비검사(try-catch, throws)가 아닌 것 중 RuntimeException이 아닌 경우도 있다. 바로 Error다.

RuntimeException과 Error 둘 다 동작 측면에서는 다르지 않다.

프로그램에서 잡을 필요가 없거나 혹은 복구를 하려고 해봐야 득보다는 실이 많다는 뜻으로 비검사 예외나 에러를 던지기 때문이다.

이런 경우 스레드는 적절한 오류 메시지를 내뱉으며 중단된다.

에러는 보통 JVM이 메모리 공간이 부족하는 등 자원이 부족하거나 불변식(클래스 내부의 상태 무결성을 위한 규칙)이 깨져 프로그램의 수행을 계속할 수 없는 상황에 사용된다.

`자바 업계에서는 Error 클래스를 상속해 하위 클래스를 만드는 일은 자제하자는게 널리 퍼진 규약이니, Error 클래스를 상속하는 것은 피하자.`

즉, 직접 구현하는 비검사 Throwable 은 모두 RuntimeException의 하위 클래스여야 한다.(AssertionError는 예외~)

정리하자면

1. 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자.
2. 확실하지 않으면 비검사 예외를 던지자.
3. 검사 예외도 아니고 런타임 예외도 아닌 Throwable은 정의하지도 말자.
4. 검사 예외의 경우 복구에 필요한 정보를 알려주는 메서드도 함께 제공하자.
