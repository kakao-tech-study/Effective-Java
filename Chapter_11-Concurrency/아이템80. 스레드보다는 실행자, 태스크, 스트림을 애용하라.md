# 아이템80. 스레드보다는 실행자, 태스크, 스트림을 애용하라

⏪️ 과거: 작업 큐 클래스 → 클라이언트가 요청한 작업을 백그라운드 **스레드**에 위임해 비동기적으로 처리

작업 큐에 중단을 요청하면 남은 작업을 완료한 후 스스로 종료한다.

간단한 코드도 **안전 실패와 응답 불가를 방지**하기 위한 코드로 인해 복잡해졌다.

이제는 **실행자, 태스크, 스트림**을 사용하여 이러한 복잡한 코드를 작성하지 않아도 된다.

✅ **`java.util.concurrent` 패키지 등장**

→ 이 패키지는 **실행자 프레임워크(Executor Framework)**라고 하는 인터페이스 기반의 유연한 테스크 실행 기능을 담고 있다.

과거 보다 많이 간단해졌다.

`ExecutorService exec = Executros.newSingleThreadExecutor();`

→ 실행자 프레임워크 생성

`exec.execute(runnable);`

-> 실행자에 실행할 Task를 넘기는 방법

`exec.shutdown();`

→ 실행자를 종료시키는 방법

✅ **장점**:

1. **안전성 향상**: 직접 스레드 다루는 코드보다 실패 대응이 좋고 응답 불가 문제도 줄어듦.
2. **코드 간결성**: 단순한 코드로 강력한 기능 구현 가능.
3. **유연성**: 단일 스레드, 스레드 풀 등 다양한 실행 정책 적용 가능.

**✅ ExecutorService의 주요 기능**

1. **특정 태스크가 완료되기를 기다림**: Future.get() 등을 사용해 결과를 기다릴 수 있음.
2. **태스크 모음 중 아무거나 혹은 모두 완료될 때까지 기다림**: invokeAny(), invokeAll() 사용.
3. **실행자 서비스 종료 대기**: awaitTermination()으로 안전하게 종료 대기 가능.
4. **완료된 태스크 결과 처리**: ExecutorCompletionService 사용.
5. **태스크를 주기적으로 실행**: ScheduledThreadPoolExecutor 사용.

**✅ 다양한 스레드 풀 구성**

**단일 스레드**만 사용하는 기본 예시 외에, **스레드 풀**을 사용하면 더 많은 태스크를 병렬로 처리 가능.

1. **Executors.newCachedThreadPool()**
    
    **특징**: 필요 시 새로운 스레드를 계속 생성.
    
    **장점**: 짧고 많은 요청에 적합. 사용이 간단.
    
    **단점**: 무한정 스레드가 생기므로, 서버 과부하 위험. **프로덕션 환경에서는 비추천**.
    
2. **Executors.newFixedThreadPool(n)**
    
    **특징**: 스레드 수를 고정. 안정적인 실행 가능, 무거운 서버 환경, 예측 가능한 작업량에 적합
    
3. **ThreadPoolExecutor 직접 생성**
    
    **장점**: 풀의 크기, 큐 종류, 태스크 거부 정책 등 세세한 설정 가능.
    
    **단점**: 복잡하고 실수 위험 있음.
    

**✅ 실행자 프레임워크 vs 직접 스레드 사용**

Thread 직접 생성 시: 작업 실행과 관리(예: 예외처리, 대기, 취소)를 직접 다루어야 함.

Executor 사용 시: **실행자 프레임워크가 실행 정책과 스레드 관리**를 모두 대신해 줌.

따라서, **책임 분리가 가능**하고 유지보수성이 높아짐.

**❓작업 단위: Runnable vs Callable**

**Runnable:** 반환값 없음, 예외 던지지 못함

**Callable:** 값 반환 가능, 예외 던질 수 있음

둘 다 ExecutorService에서 실행 가능하며, Future로 결과를 비동기적으로 받을 수 있음.

**✅ 고성능 병렬 작업: Fork/Join 프레임워크**

자바 7부터 도입된 **Fork/Join 프레임워크**는 큰 작업을 작은 단위로 나눠 병렬로 처리.

**ForkJoinPool:** 병렬 실행을 위한 스레드 풀.

**ForkJoinTask:** 병렬 작업을 표현한 클래스.

**작동 방식:** 작업을 분할 (fork) → 결과를 합침 (join) → 작업이 끝난 스레드는 다른 작업을 도와줌 (작업 훔치기 - work stealing)

**장점:** CPU 활용 극대화, 높은 처리량과 낮은 지연 시간

**✨ 정리**

1. 스레드 직접 생성은 예외 상황, 자원 회수, 큐 관리 등 **복잡한 문제를 수반**.
2. 대신 **Executor + Task(Runnable/Callable)** 조합을 사용해 **효율적이고 안전한 병렬 처리**를 구현하자.
3. **Fork/Join**은 대량 병렬 작업에 적합.
