### 아이템61. 박싱된 기본 타입보다는 기본 타입을 사용하라

**✅ 자바의 데이터 타입 두가지!**

1. **기본 타입** : int, double, boolean 등
2. **참조 타입**: String, List, Integer, Double, Boolean 등

**오토 박싱, 오토 언박싱** → 두 타입을 크게 구분하지 않고 사용하게 해준다.

**그러나, 차이가 사라지는 것은 아니다!** → 따라서 주의해서 사용해야 한다.

**🆚 기본 타입, 박싱된 기본 타입 주된 차이 3가지:**

1. **기본 타입**은 **값**만
**박싱된 기본 타입**은 **값 + 식별성**
2. **기본 타입**은 **언제나 유효**
**박싱된 기본타입**은 **유효하지 않은 값, null을 가질 수 있음**
3. **기본 타입**이 박싱된 기본 타입보다 **시간과 메모리 사용면에서 더 효율적**

→ ⚠️ 이 세가지 차이점으로인해서 주의하지 않고 사용 시, 문제가 발생할 수 있다.

**Integer 값을 오름차순으로 정렬하는 비교자)**

```java
Comparator<Integer> naturalOrder =
	(i, j) -> (i < j) ? -1 : (i == j ? 0 : 1)
```

실제로 작동 시켜본다면, 아무런 문제가 없어 보이나 치명적인 결함이 있다.

(`new Integer(42)`, `new Integer(42)`)를 넣었을때, 같은 값을 비교하는 상황임에도 불구하고

0이 아닌 1을 출력한다. → 첫 검사, `(i < j)` 는 통과했으나 같은 값을 비교하는 곳에서 식별성을 검사했을때, 앞이 더 크다고 판단하기 때문에 그렇다.

결국, **박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.**

🤔 이와 같이 **기본 타입을 다루는 비교자**가 필요하다면?

`Comparator.naturalOrder()`를 사용해야한다.

**비교자를 직접 만들면** 비교자 생성 메서드나 기본 타입을 받는 **정적 compare 메서드**를 사용해야한다.

위 문제를 고치려면 지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한 다음, 모든 비교를 이 기본 타입 변수로 수행해야한다.(이렇게 하면 식별성 검사가 이루어지지 않는다.)

**문제를 수정한 비교자**)

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
	int i = iBoxed, j = jBoxed;
	return i < j ? -1 (i == j ? 0 : 1);
};
```

**박싱된 기본 타입의 문제점**:

**기본 타입과 박싱된 기본 타입을 혼용한 연산**에서는 **박싱된 기본 타입의 박싱이 자동으로 풀린다.**

그리고 null 참조를 언박싱 하면 `NullPointerException`이 발생한다.

그렇다면 박싱된 기본 타입이 적절히 쓰이는 경우?

→ 컬렉션의 원소, 키, 값으로 쓴다. (컬렉션은 기본 타입을 담을 수 없으므로)

더 일반화하면,

**매개변수화 타입이나 매개변수화 메서드**의 **타입 매개변수로는 박싱된 기본 타입**을 써야한다.

(자바가 타입 매개변수로 기본 타입을 지원하지 않기때문)

핵심 정리

**기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라.**

기본 타입은 간단하고 빠르다.

**박싱된 기본 타입을 써야 한다면 주의를 기울이자.** 

오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다. 

두 박싱된 기본 타입을 == 연산자로 비교한다면 식별성 비교가 이뤄지는데, 이는 여러분이 원한 게 아닐 가능성이 크다. 

같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, 

언박싱 과정에서 `NullPointerException`을 던질 수 있다.

 마지막으로, **기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 낳을 수 있다.**
