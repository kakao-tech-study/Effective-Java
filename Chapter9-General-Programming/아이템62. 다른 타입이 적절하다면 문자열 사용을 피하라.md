# 다른 타입이 적절하다면 문자열 사용을 피하라

```
헉 오늘 일반선택 수업에서 발표가 있는데요 운이 좋게도 
저는 다음주 발표자여가지구 떨리지는 않지만 다음주에는 너무 떨릴 것 같아요..!
다들 발표 잘하시나요..? 전진짜 발표 헤이러에용 ㅎ
오늘도 사담으로 시작 ... ^_^ 
```

## 문자열의 잘못된 사용
1. 열거타입은 열거 타입으로
2. 문자열은 혼합 타입은 클래스로
    ```java
    String className = "프레젠테이션";
    String compoundKey = className + "#" + className.hashCode();
    ```

1번과 2번 모두 이펙티브 자바를 다루면서 배워온 개념입니다!

클래스가 아닌 문자열을 사용한다면, 값의 일관성, 제약 사항들을 적용하기 힘들다는 단점이 있습니다.    
특히 오타와 관련해서 어이없는 실수를 저지를 수 있다는 문제점이 있죠!

**문자열이 아닌 클래스를 쓰는 것이 파싱, 유효성 검사등을 적용하기 좋고 장기적으로 유리합니다.**

그런데 오늘은 문자열이 저장위치인 상수풀과, 스레드의 메모리 공유 특징과 관련해서 문자열을 키 값으로 사용할때의 문제점을 다뤄보겠습니다. 
## 자바에서 스레드끼리 공유하는 메모리 영역

- `static` : 클래스 정보, 상수 풀, 정적 변수가 저장 되는 공간
- `stack` : 스레드마다 하나씩 가지며, 메서드 호출이 하나의 스텍 프레임을 가지게 됩니당. 
- `Heap` : 객체 인스턴스와 배열이 저장되는 공간 


### **스레드는 어떻게 메모리 구조를 가지고 갈까요?**   
스레드는 자신만의 스택 영역,(PC 레지스터, 네이티브 메서드 스택)을 가집니다. 

스레드A와 스레드B는 동일한 스레드 영역과 힙 영역을 공유합니다.

결국 모든 스레드가 특정 정적 변수에 다같이 접근할 수 있고, 스레드A가 만든 객체를 스레드B가 접근할 수 있습니다.


## 스레드 별로 식별을 위한 키값이 필요할 때
> 스레드 별로 식별값이 필요한 상황..!

이 식별 값을 문자열로 사용할 때의 문제점을 스레드가 가지는 메모리 특성과 연결지어서 설명하겠습니다.

완벽한 코드를 적어놓은 것이 아닌, 아주아주 단순화된 코드이며 따라서 상세한 로직보다는 핵심만 이해하도록 합시다. 

먼저, 위에서 스레드는 스택 영역은 별도로 사용하지만, 클래스 정보다 올라가는 스태틱 영역은 공유한다는 것을 다시 한번 기억할게요!

### (1) 스레드 키 값을 클래스 변수로 사용할 때

```java
class ThreadLocal {

    private ThreadLocal() {}

    public static void set(String key, Object value) {}
    public static Object get(String key){}

}
```
#### 단점    
키 값이 문자열!!이고 문자열은 상수 풀에, 상수풀은 스태틱에 저장됩니다.    
결국 키 값이 모든 스레드가 공유하는 곳에 저장됩니다. 

그리고 이 키 값을 만드는 것에 **어떠한** 규제도 없습니다.   
즉 스레드 별로 동일한 문자열로 키 값을 설정할 위험이 있습니다.

결국, 스레드를 구분하기 위한 키가 제대로 동작하지 않을 위험이 있습니다.

> 문자열이 저장되는 위치, 문자열을 만드는 데에는 어떠한 규약도 없다는 것이 문제점!
 
### (2) 키를 고유한 인스턴스로 구현
```java
public class ThreadLocal {
    private ThreadLocal() { } // 객체 생성 불가
    
    // 내부 static 클래스 Key 정의
    public static class Key { // (권한)
        Key() { }
    }
    
    public static Key getKey() {
        return new Key();
    }
    
    public static void set(Key key, Object value) {}
    
    public static Object get(Key key) {}
}
```

#### 코드 설명
왠지 위의 설명을 듣고... key 인스턴스는 스레드 별로 고유한 곳에 저장되겠구나! 라고 짐작하실 수 있을 것 같아요!!    
그렇지만, 인스턴스는 힙영역에 저장되고 힙영역은 모든 스레드가 공유합니다!!

그렇지만, 이 (2)  key 값은 개발자가 동일한 객체를 임의대로 만들 수 없습니다.  
또한 이 (1)key값을 참조하는 참조 변수는 스택 영역, 스레드별로 가지는 고유한 영역에 저장됩니다.

결국 스레드A와 스레드B가 동일한 key라는 변수명의 key인스턴스를 키값으로 가지고 있다고 하더라도,
(1) 변수명은 서로 다른 메모리에 위치한 별개의 참조변수고, (2) key 객체를 만드는 과정에서 별개의 객체가 만들어지기 때문에 안전하게 사용 가능한것이죠! 

> Key 인스턴는 힙에 저장되고, Key 인스턴스는 고유
> Key 객체를 참조하는 변수는 각 스레드의 고유한 스택 영역에 저장, 또한 클래스이기 때문에 이런 저런 규약 추가 가능

### (3) 리팩토링
(2)번 코드는 (1)번의 문제를 해결합니다.     
그렇지만 2번코드는 클래스가 불필요하게 중복되어있고, 해당 값을 단순 `Object`로 사용하고 있다는 보완할 점이 있습니다. 

따라서 다음과 같이 보완할 수 있습니다! 
```java
public final class ThreadLocal {
    public ThreadLocal();
    public void set(Object value);
    public Object get();
}
```
```java
public final class ThreadLocal<T> {
   public ThreadLocal();
   public void set(T value);
   public T get();
}
```

### 마무리하면서
```
제목은 문자열이지만, 스레드를 더 깊이 다룬 것 같은..! 느낌이네요 !
이렇게 저렇게 공부를 하는 건 늘 좋은 일이라고 생각해요!
```
