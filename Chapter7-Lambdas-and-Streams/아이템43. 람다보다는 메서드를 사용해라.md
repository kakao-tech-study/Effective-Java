# 람다보다는 메서드 참조를 사용하라

```
언젠가는 공부해야하는 것들 중에 메서드 참조가 있었는 데,
이렇게 공부하니 좋네요! 

... 사실 안좋고요 꽤 헷갈리는 군여
```

## 람다를 왜 쓰나요?
람다는 함수형 인터페이스를 사용하는 상황에서, 매번 클래스나, 익명클래스를 구현해야하는 번거로움을 해결하기 위해 도입되었다.

람다의 유용성은 **간결함**에 있다.   
람다를 쓰면서 함수를 변수로 저장해 전달하고, 재사용하는 것이 가능해졌다.

결국 람다를 쓴다는 것은 **함수형 인터페이스를 구현하는 과정을 단축**하는 것이다. 

람다 사용의 흐름도를 간략하게 살펴볼게요!
```java
1. 함수형 인터페이스를 매개변수로 받는 어떤 메서드
R method(Function<T,R> funtion);

2. 함수형 인터페이스의 메서드
public interface Function<T,R> {
    R apply(T t);
}        
        
3. 실제 람다
method((t) -> r)
```

람다를 쓰기 위해서는 1번과 2번은 항상 동일하게 적용되는 규칙입니다.    
함수형 인터페이스가 있고, 그 인터페이스를 매개변수로 받는 메서드에 람다를 쓸 수 있는 것이죠!!

사실 3번에 람다를 쓰는 것도 동일하지만, 람다를 쓰는 방식에는 여러가지가 있습니다.    
간단한 연산식, 특정 상수 변환, 조건식부터 아예 괄호`{}`로 묶고 여러 구문을 쓸 수도 있습니다.

**중요한건 그 람다식이 함수형 인터페이스의 메서드 구현을 하기만 하면 되는 것이거든요!**


## 메서드 호출로 람다식을 표현해보자

위에서 3번, 람다식의 표현중에 메서드 호출이 있다고 말씀드렸는데요! 이 경우에 대해 자세히 살펴보도록 해볼게요!

위 흐름에서 문자열을 받아서 숫자를 반환하는 람다식을 만들어보고 싶어요.   
문자열(Sting)을 받아서 숫자(Interger)를 반환하니까 함수형 인터페이스 Function을 사용하기에도 정말 안성맞춤이죠? 

```java
// 1. strem 메서드인 map은 입력매개변수로 함수형 인터페이스를 받는다. Function
<R> Stream<R> map(Function<? super T, ? extends R> mapper);


// 3.메서드 호출로 람다식 표현
List<Integer> integers = strings.stream()
        .map(str -> Integer.parseInt(str))
        .toList();

// 실제 메서드 코드 확인, 함수형 인터페이스의 메서드와 입력값, 반환값 (시그니처)가 동일하다.
public static int parseInt(String s) throws NumberFormatException {
        return parseInt(s, 10);
    }
```

결국 이미 정의 된 메서드를 활용해 깔끔하게 구현을 성공했네요
만약 메서드를 호출하는 람다식이 아니였다면, 저 stream 도중에 함수형 인터페이스를 구현해야하고 그 생각을 하면 참~ 어질어질하죠??

그런데 여기서 str이 왠지 반복되는 것 같고, 더 간략하게 줄일 수 있을 것 같단말이죠?? 🤔🤔

## 메서드 참조를 알아보자
메사드 참조는 람다식에서 파라미터에 따른 과정(동작)이 아닌 실제 메서드명을 참조하게 하는 것이에요.
명시적으로 메서드명을 참조해 가독성을 한번 더 높일일 수 있죠!



책에서는 메서드 참조의 용법을 5가지 유형으로 나누어 설명하고 있는데, 저는 조금 더 풀어서 설명을 드려보도록 할게요.

#### 1. 람다식의 파라미터가 메서드의 입력값으로 활용되는 경우
```java
// 람다식
str -> Integer.parseInt(str)
// 메소드 참조
Integer::parseInt
```
이때 `Integer`의 메서드를 바로 호출하기 때문에 정적 메서드 참조 유형이라고도 부릅니다. 

#### 2. 람다식 파라미터의 메서드를 호출하는 경우 (람다식의 파라미터가 해당 메서드를 가지고 있는 상태)
```java
// 람다식
(String s) -> s.length()
// 메소드 참조
String::length 
```
뭔가 변수명이 사라져서 당황스러울 수 있지만 메서드참조가 사용되는 ***컨텍스트**에 따라 컴파일 하고 동작합니다. 

#### 3. 람다식의 파라미터가 메서드의 입력값으로 활용되지만, 메서드가 특정 변수(인스턴스)의 메서드일 때
```java
// 특정 객체 obj가 있을 때
// 람다식
x -> obj.someMethod(x)
// 메소드 참조
obj::someMethod
```
람다식의 파라미터는 메서드의 입력값으로 활용되고 메서드는 특정 변수의 메서드를 활용합니다. 

#### 4. 생성자를 호출할 때
```java
// 람다식
() -> new ArrayList<>()
// 메소드 참조
ArrayList::new
```
#### 5. 배열 생성자를 호출할 때
```java
// 람다식
size -> new int[size]
// 메소드 참조
int[]::new
```

### 실제로 해보자
```java
// 3.메서드 호출로 람다식 표현
List<Integer> integers = strings.stream()
        .map(str -> Integer.parseInt(str))
        .toList();
```
위 코드를 어떻게 메서드 참조로 바꿀 수 있을까요??   
람다 파라미터의 입력값이 그대로 메서드의 입력값으로 사용되고 있고   
`parseInt`메서드는 정적 메서드로 객체 참조 변수가 필요없는 정적메서드입니다.  

따라서 다음과 같이 바꿀 수 있습니다~! 
```java
List<Integer> integers = strings.stream()
            .map(Integer::parseInt)
            .toList();
```

많은 것이 생략되어보이는데 어떻게 컴파일러는 메서드 참조를 해석하고 동작시킬까요? 바로 컨텍스트 덕분인데요? 
바로 컨텍스트 덕분인데요. 아래 설명을 덧붙여놨습니당. 


메서드 참조를 설명하기 위해 정말 많은 단계를 거쳐왔지만, 메서드 참조 용법 설명은 여기까지 하도록 하겠습니다.

메서드 참조의 모든 유형을 완벽히 설명하는 것은 사실상 어렵기 때문인데요.   
왜냐하면 메서드 참조의 세부적인 유형은 결국 사용되는 함수형 인터페이스의 시그니처에 따라 결정되거든요. 

메서드 참조를 더 깊이 이해하고 싶다면, 다양한 함수형 인터페이스의 특성과 활용법을 함께 공부하는 것을 추천합니다. 이를 통해 더 간결하고 가독성 높은 코드를 작성할 수 있을 것입니다. ^_^

하지만 메서드 참조를 더 잘이해하기 위한 방법은 말씀드리도록 하겠습니다.

결국 중요한 것은 **메서드 참조는 함수형 인터페이스**를 구현하는 방법이고, 
따라서 어떤 특정 유형으로 공부하기보다는 지금 구현하고 있는 함수형 인터페이스를 확인하고, 내부 구현을 대체할 메서드명을 적어주면 됩니다. 

### 주의 할 점
메서드 참조를 쓰는 이유는 가독성 때문인데요.
그렇지만 가독성에 대해서는 개발자의 판단이 중요해요.   
만약 람다의 파라미터명이 오히려 가독성에 도움을 줄 것 같다면 람다식을 쓰는게 더 좋은 것이죠! (책에서도 동일하게 말하고 있어요!)

 개인적 의견은 IDE가 권장하는 정도의 메서드 참조, 이미 잘 쓰고 있어서 익숙한 메서드 참조정도를 쓰는게 적절하다고 생각해요!

****

### + 컨텍스트란?
**컨텍스트**란 메소드 참조가 사용되는 위치에서 기대되는 함수형 인터페이스 타입을 의미합니다.   
컴파일러는 메소드 참조를 해석할 때 **컨텍스트**를 기준으로 결정해요.

<메서드 참조 해석 과정>

1. 컴파일러는 메소드 참조가 사용되는 컨텍스트를 확인합니다
2. 해당 컨텍스트에서 요구되는 함수형 인터페이스를 파악합니다
3. 함수형 인터페이스의 추상 메소드 시그니처를 확인합니다
4. 메소드 참조가 이 시그니처와 호환되는지 확인합니다

그렇기 때문에 람다식에 비해 많은 것이 생략되어도 컨텍스트를 기준으로 정상 동작할 수 있는 것이죠!

****



