### 아이템51. 메서드 시그니처를 신중히 설계하라

**API 설계 요령**

**🤔 메서드 이름을 신중히 짓자.**

같은 개념을 나타내는 메서드는 **일관된 이름을 사용해야 한다**.

개발자 커뮤니티에서 널리 사용되는 명칭을 선택하라.

**⚠️ 편의 메서드는 너무 많이 만들지 말 것.**

메서드는 **각각의 소임이 명확해야 하며, 너무 많으면 오히려 사용성을 해친다**.

자주 사용하는 경우에만 별도의 **오버로딩된 메서드를 제공**하는 것이 좋다.

**⚠️ 매개변수 목록은 4개 이하로 유지하는 것이 바람직하다.**

**매개변수가 많으면 사용하기 어렵고, 실수 가능성이 높아진다**.

같은 타입의 매개변수가 연달아 나오면 **사용자가 순서를 헷갈릴 가능성이 크다**.

**✅ 기능별로 메서드를 분리하라.**

**하나의 메서드에서 여러 기능을 처리하지 말고, 필요한 기능을 개별적으로 제공**하라.

예: List 인터페이스의 subList()와 indexOf()처럼 **기능별로 분리하면 직관적이고 유지보수하기 쉽다**.

**🤔 API 설계 시 직교성(orthogonality)을 고려하라.**

**각 메서드는 독립적으로 동작해야 하며, 불필요한 중복을 피해야 한다**.

이를 통해 **API가 명확해지고 사용하기 쉬워진다**.

**❗️ 직교(Orthogonal)** 란 수학에서 **서로 독립적인 요소**를 의미하며, 소프트웨어 설계에서도 동일하게 적용됨.

**직교성이 높은 설계**란 **중복 없이 기능이 잘 분리되어 있고, 조합하여 새로운 기능을 만들기 쉬운 구조**를 의미함.

**✨ 직교성이 높은 API 설계의 장점**

1.  **중복 감소** → 동일한 기능을 여러 번 구현할 필요 없음.
2.  **유지보수 용이** → 개별 기능을 수정해도 다른 기능에 영향을 주지 않음.
3.  **테스트 용이** → 개별 기능을 독립적으로 검증 가능.
4.  **유연하고 강력함** → 기본 기능 몇 개만 조합해 다양한 기능을 구현할 수 있음.

**📝 예시: API 설계에서의 직교성**

List 인터페이스의 subList()(부분 리스트 반환)와 indexOf()(특정 요소의 인덱스 찾기)는 독립적인 기능이므로 별도 메서드로 분리하는 것이 바람직함.

불필요한 편의 기능을 추가하는 대신 **기본 기능을 원자적으로 제공하면 API가 가벼워지고 직교성이 높아짐**.

**⚠️ 직교성이 낮을 때의 문제점**

 비슷한 기능이 중복되면서 API가 불필요하게 방대해짐.

 하나의 기능을 변경할 때 여러 부분을 수정해야 하므로 유지보수가 어려워짐.

 **✅ 적절한 직교성 유지의 중요성**

**🚫 모든 기능을 무조건 쪼개는 것이 능사는 아님**.

 자주 사용되거나 성능 최적화가 필요한 기능은 편의 메서드로 제공할 수도 있음.

 **일관된 원칙과 철학을 가지고 직교성을 조절하는 것이 중요**함.

**🔍 확장: 소프트웨어 설계 전반에서의 직교성**

**CPU 명령어 설계**: RISC(직교성이 높음) vs. CISC(직교성이 낮음).

 **소프트웨어 아키텍처**: 마이크로서비스(직교성이 높음) vs. 모놀리식 아키텍처(직교성이 낮음).

 **클래스, 패키지, 모듈 설계에도 직교성 개념을 적용할 수 있음**.

**매개변수 수를 줄이는 효과적인 기술**

**✅ 매개변수를 묶는 도우미 클래스 사용**

**관련 있는 매개변수 여러 개를 하나의 클래스로 묶어 관리**하면 코드가 간결해짐.

예: **카드 게임에서 숫자(rank)와 무늬(suit)를 하나의 클래스**로 묶어 사용.

일반적으로 **정적 멤버 클래스**로 구현하는 것이 좋음.

**⚙️ 빌더 패턴을 활용한 매개변수 설정**

**매개변수가 많고 일부 선택적일 때 빌더 패턴을 활용**하면 유용함.

먼저 **모든 매개변수를 포함하는 객체를 만들고**, 클라이언트가 **필요한 값만 세터(setter)로 설정**하도록 함.

설정이 끝나면 execute() 같은 메서드를 호출해 **유효성 검사 후 연산 수행**.

**✅ 인터페이스를 매개변수로 사용하는 것이 좋음**

**클래스보다 인터페이스를 매개변수로 사용**하면 유연성이 높아짐.

예: HashMap 대신 Map을 사용하면 **다른 구현체(Treemap, ConcurrentHashMap 등)도 전달 가능**.

인터페이스 대신 특정 클래스를 사용하면 **사용자가 특정 구현체로 변환하는 추가 비용을 부담할 수도 있음**.

**✅ boolean 대신 두 개의 원소를 가진 열거 타입 사용**

**메서드에 boolean을 넘기는 것보다, 의미를 명확히 전달하는 열거 타입을 사용**하는 것이 좋음.

예시)

```java
public enum TemperatureScale { FAHRENHEIT, CELSIUS }
```

`Thermometer.newInstance(TemperatureScale.CELSIUS);`

newInstance(true)보다 의미가 명확해짐.

**추가적인 선택지(Kelvin 등)를 쉽게 확장할 수 있음**.

열거 타입 내부에 관련 변환 메서드를 포함하면 코드 관리가 더 쉬워짐.

**즉, 매개변수를 줄이면서도 코드의 가독성과 유지보수성을 높이려면, 도우미 클래스, 빌더 패턴, 인터페이스 활용, 열거 타입 사용 등의 기법을 적절히 적용해야 한다**.
