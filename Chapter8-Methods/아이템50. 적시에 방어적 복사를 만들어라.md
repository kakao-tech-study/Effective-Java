# 적시에 방어적 복사를 만들어라

## 방어적 복사는 무엇일까?
**방어적 복사란** 객체를 생성하거나, 객체 필드를 반환할 때 복사본을 만들어 **외부의 변경에 의해** 객체 필드가 영향받지 않도록 보호하는 방법이다.

1. 생성시 가변 매개변수를 그대로 사용하지 않고, 별개의 주소를 갖는 객체를 생성한 후 필드를 초기화한다.
2. 객체 필드를 반환하는 메서드 (ex_`getter`)에서 객체를 반환하는 게 아니라, 새로운 주소를 가지는 객체를 생성한 후 반환하다.

결국 방어적 복사는 객체가 의도하지 않은 변경이 일어나지 않도록 하는 방법이다.

## 외부 변경에 의해 객체 내부가 변경되는 경우 

1. 객체 필드를 `final`로 선언해 불변 객체를 만들었다.
성공적으로 불변 객체를 만든 것 같지만 name 객체가 가변 객체라면? 
    ```java
    class Person{
        private final Name name;
    
        public Person(Name name) {
            this.name = name;
        }
    }
    
    ```


2. name 클래스는 가변 객체였다.
    ```java
    class Name {
       private String name;
    
       public Name(String name) {
       this.name = name;
       }
    
       public void setName(String name) {
       this.name = name;
       }
    }
    ```

3. 외부 변경으로 인해 불변객체라 생각했던 person의 값이 달라진다.
    ```java
    Name seohyun = new Name("서현");
    Person seohyunPerson = new Person(seohyun);

    System.out.println(seohyunPerson); //Person{name=서현}

    seohyun.setName("서경");

    System.out.println(seohyunPerson); //Person{name=서경}
    ```



## 방어적 복사를 하는 구체적 방법
#### 생성자의 방어적 복사
1. 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만든다.
2. 방어적 복사를 쓸때 `clone()`을 사용하지 않고, 생성자를 통해 직접 복사한다. 
    해당 클래스가 하위 클래스 타입에서 오버라이딩 될 수 있기 때문이다. 

```java
class Person{
    private final Name name;

    public Person(Name name) {
        Name newName = new Name(name.getName());
        this.name = newName;
    }
```
#### 접근자의 방어적 복사
1. 객체필드를 반환할 때 방어적 복사본을 만들어 제공한다. 
   객체 필드를 직접 반환하는 경우 외부에서 해당 값을 변경할때 내부 필드도 변경되기 때문이다.
2. 생성자 단계에서 객체 내부 필드를 독립적으로 방어적 복사했기 때문에 여기서는 `clone()`을 해도된다. 
```java
    public Name getName() {
        return new Name(name.getName());
    }

```

## 방어적 복사의 사용을 고민해보자
외부에서 받은 객체의 참조를 객체 내부에 사용해야할 때면 그 객체가 변경 될 수 있는지,   
변경될 가능성이 있어도 그 객체가 문제없이 동작할지 고민해야한다. (~~그렇지만 이런 경우가 없지 않을까요..?~~)
만약 조금이리도 문제가 생길 것이라 판단된다면 방어적 복사를 사용해야한다.

그러나, 방어적 복사는 메모리를 그만큼 더 사용하기 떄문에 성능 저하를 가져오기도 한다. 
그래서 복사 비용이 너무 커서 성능 저하가 우려된다면 문서에 방어적 복사의 위험을 충분히 고지하고 생략해도 된다.

생략해도 되는 경우
1. 접근자나 생성자로 객체를 받아올 때 수정 권한이 넘어옴을 명확히 인지할 때
2. 신뢰할 수 있는 클라이언트인 경우
3. 불변식이 꺠지더라도 그 영향이 호출한 클라이언트로 국한될 때 한정해야한다. 예를 들어 래퍼 클래스 패턴이 있다. 

그러나 위 세가지 경우를 제외하고는 방어적 복사를 사용하는 것이 더 적절하다.


### + 보너스) 얕은 복사 vs 깊은 복사의 차이와 방어적 복사와의 관계
 얕은 복사(Shallow Copy):
- 객체의 최상위 수준만 복사한다.
- 따라서 내부 객체는 원본과 복사본이 같은 참조를 공유한다. (위 예시에서 잘못된 경우가 이에 해당)
- clone() 메서드나 복사 생성자가 일반적으로 제공하는 기본 복사 메서드

 깊은 복사(Deep Copy):
 - 객체와 그 내부에 포함된 모든 객체들을 새로운 참조 주소를 할당해 복사한다. 
 - 원본과 복사본은 완전히 독립적인 객체 참조 주소를 가진다.
 - 객체 그래프 전체를 복제하므로 원본 객체가 변경되어도 복사본에 영향을 주지 않는다.
- 얕은 복사보다 메모리와 처리 시간이 더 많이 필요하지만, 완전한 객체 독립성을 보장한다.

방어적 복사는 가변 객체의 불변성을 보장하기 위해서는 깊은 복사를 사용하게 된다. 

### 마무리하면서
```java
결국 깊은 복사와 얕은 복사는 복사의 방법, 기술적인 이야기이고, 방어적 복사는 객체의 불변성을 보호하기 위해 전달받고 제공하는 곳에서 사용하는 전략이라 볼 수 있을 것 같네요! 
```
