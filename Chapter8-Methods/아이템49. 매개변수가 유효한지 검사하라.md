# 아이템49. 매개변수가 유효한지 검사하라. 
> 메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 예컨대 인덱스 값은 음수이면 안 되며, 객체 참조는 null이 아니어야 하는 식이다. 이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다. 이는 "오류는 가능한 빨리 (발생한 곳에서) 잡아야 한다"는 일반 원칙의 한 사례이기도 하다.

## 매개변수 검사를 제대로 하지 못 한 경우 발생하는 문제
1. 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
2. 메서드가 잘 수행되지만 잘못된 결과를 반환할 수 있다.
3. 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어 놓아 미래의 알 수 없는 시점에 이 메서드와는 관련없는 오류를 낼 수 있다.

다시말해, 매개변수 검사에 실패하면, 실패 원자성(failure atomicity, 아이템 76)을 어기는 결과를 낳을 수 있다. 

## public과 protected 메서드: 매개변수로 인한 예외는 문서화해야 한다. 
public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. @throws 자바독 태그를 사용하면 된다. 
보통은 IllegalArgumentException, IndexOutOfBoundsException, NullPointerException 중 하나가 될 것이다. 

매개변수의 제약을 문서화 한다면, 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다. 이를 통해 API사용자가 제약을 지킬 가능성을 높일 수 있다. 
```
    /**
     * 현재 값 mod m 값을 반환한다.
     * 항상 음이 아닌 BigInteger를 반환한다.
     * 
     * @param m 계수(양수여야 한다.)
     * @return 현재 값 mod m
     * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
     */
    public BigInteger mod(BigInteger m){
        if(m.signum() <= 0)
            throw new ArithmeticException("계수(m)은 양수여야 합니다. "+ m);

        return m.mod(m);
    }
```
위 코드에서 m이 null이면 m.signum() 호출 때, NullPointerException을 던지다. 하지만, 이에 대한 말은 메서드 설명에 없다. 이는 이 설명을 개별 메서드가 아닌 BigInteger클래스 수준에서 기술했기 때문이다. 클래스 수준 주석은 그 클래스의 모든 public 메서드에 적용되므로 각 메서드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다. 
<img width="420" alt="image" src="https://github.com/user-attachments/assets/54d49e5f-135a-481c-ab65-be68b5547bce" />
실제로 BigInteger 클래스 내 주석에는 위와 같은 설명이 기재되어 있다. 

## Objects의 유효성 검사 메서드

### 간편한 null 검사: java.util.Objects.requireNonNull 메서드
> 자바7 에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기도 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다. 원하는 예외 메시지도 지정할 수 있다. 또한, 입력을 그대로 반환하므로 사용하는 동시에 null 검사를 수행할 수 있다.

```
String value = null;
Objects.requireNonNull(value, "null이 되면 안돼");
```
<img width="649" alt="image" src="https://github.com/user-attachments/assets/b1a9af2b-cd3b-4a5a-aa0f-a25436f8d67c" />

### 범위 검사: checkFromIndexSize, checkFromToIndex, checkIndex 메서드
> null 검사만큼 유연하지는 않다. 예외 메시지를 지정할 수 없고, 리스트와 배열 전용으로 설계됐다. 또한 닫힌 범위(closed range)는 다루지 못한다. 

## private 메서드: 단언문을 사용한 매개변수 유효성 검증
> 공개되지 않은 메서드라면 제작자가 메서드가 호출되는 상황을 통제할 수 있다. 유요한 매개변수가 들어온다는 것을 충분히 보증할 수 있고, 또 그렇게 해야 한다. 이런 상황에서는 예외가 아닌 단언문(assert)를 사용해 매개변수 유효성을 검증할 수 있다.

```
private static void sort(long a[], int offset, int length){
    assert a != null;
    assert offset >= 0;
    assert length >= 0;
    ...
}
```
핵심은 이 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다. 

단언문은 일반적이 유효성 검사와 다르다. 
1. 실패하면 `AssertionError`를 던진다.
2. 런타임에 아무런 효과도, 아무런 성능 저하도 없다. 

## 메서드를 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수

> 메서드를 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 더 신경써 검사해야 한다.

만약 이 검사를 생략한다면 클라이언트가 사용하려 할 때 비로서 에러가 발생한다. 이때가 되면 어디서 문제가 발생했는지 추적하기 어려워 디버깅이 상당히 괴로워질 수 있다. 

**생성자**는 "나중에 쓰려고 저장하는 매개변수의 유효성을 검사하라"는 원칙의 특수한 사례다. 생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다. 

## 매개변수 유효성 검사의 예외
> 메서드 몸체 실행 전 매개변수 유효성을 검사해야 한다는 규칙에도 예외는 있다. 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때다. 

예를들어 Collections.sort(List) 처럼 객체 리스트를 정렬하는 메서드의 경우 리스트 안의 객체들은 모두 상호 비교될 수 있어야 하며, 이 과정에서 사실상 유효성 검사가 이루어진다. 그 객체와 비교할 때 비교될 수 없는 타입의 데이터가 있을 경우 ClassCastException 이 발생하기 때문이다. 
sort() 메서드 실행 초반부에 파라미터로 들어온 List 에 대한 유효성 검사를 한다면, 사실상 두 번의 유효성 검사를 한 격이다. 

이러한 암묵적 유효성 검사에 너무 의존했다가는 실패 원자성을 해칠 수 있으니 주의해야 한다. 

<hr>

# 정리하지면
> 이번 아이템을 "매개변수에 제약을 두는 게 좋다"고 해석해서는 안 된다. 사실 그 반대다. 메서드는 최대한 범용적으로 설계해야 한다. 메서드가 건네 받은 값으로 제대로 된 일을 할 수 있다면, 제약이 적을수록 좋다.

> 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 한다. 이러한 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 한다. 


