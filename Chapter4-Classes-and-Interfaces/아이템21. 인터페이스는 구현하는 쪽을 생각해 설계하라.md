### 아이템21. 인터페이스는 구현하는 쪽을 생각해 설계하라

⏪️ 자바 8전, **기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가 할 방법 X**

⏩️ 자바 8이후, 기존 인터페이스에 메서드를 추가할 수 있도록 **디폴트 메서드** 소개

(위험이 완전히 사라진 것은 X)

❓**디폴트 메서드?**

디폴트 메서드는 인터페이스에서 "이렇게 하면 될 것이다"라고 미리 알려주는 설명서와 같은 것이다.

쉽게 설명하면 다음과 같다:

```java
interface Animal {
    void makeSound();  // 각자 다르게 만들어야 하는 부분
    
    // 설명서처럼 미리 만들어둔 부분
    default void sleep() {
        System.out.println("Zzz...");
    }
}
```

여기서 `makeSound()`는 각 동물마다 다르게 만들어야 하지만, `sleep()`은 "이렇게 하면 된다"라고 미리 알려준 것이다.

필요하다면 다르게 만들 수도 있지만, 대부분은 이 설명서대로 따라하면 된다.

→ 핵심 **컬렉션 인터페이스**들에 다수의 디폴트 메서드가 추가되었다.(주로 **람다**를 활용하기 위해서)

예시로 Collection 인터페이스에 추가된 **removeIf 메서드**가 있다.

```java
default boolean removeIf(Predicate<? super E> filter){
	Objects.requireNonNull(filter(;
	boolean result = false;
	for (Iterator<E> it iterator(); it.hasNext();){
		if(fiter.test(it.next())) {
			it.remove();
			result = true;
			}
		}
		return result;
	}
```

✅ 이는 주어진 **boolean 함수(Predicate)가 true를 반환 하는 모든 원소를 제거** 하는 메서드이다.

❓**원리**

1. for 문을 통해서 순회하면서 각 원소를 인수로 넣어 Predicate 호출 → true 반환
2. Predicate가 true 반환하면 for 문 내 remove 메서드 호출 → 원소 제거

⚠️ 이 코드보다 더 범용적으로 구현하기는 어렵지만, 그렇다고 **모든 Collection 구현체와 잘 어우러지는 것은 아니**다.

대표적 예)

`apache.commons.collections4.collection.synchronizedCollction` (아파치 버전)

≈ `java.util.Collections.synchronizedCollection` (자바 버전)

아파치 버전 → **클라이언트가 제공한 객체로 락을 거는 능력** 추가로 제공

즉, 모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스다.

❓**이 예시가 대표적인 이유는?**

**모든 메서드 호출을 알아서 동기화해주지 못한다.**

removeIf가 동기화에 대한 고려 없이 구현되어 있어서,

**외부에서 락을 걸더라도 removeIf 메서드 내부에서는 동기화가 보장되지 않기 때문**이다.

이는 멀티스레드 환경에서 심각한 문제를 일으킬 수 있다

→ (SynchronizedCollection 인스턴스를 여러 스레드가 공유하는 환경에서 한 스레드가 removeIf를 호출하면 ConcurrentModificationException이 발생, 다른 예기치 못한 결과로 이어질 수 있음)

```java
// 멀티스레드 환경에서 문제가 발생할 수 있는 예시
Collection<String> synchronizedCollection = 
    Collections.synchronizedCollection(new ArrayList<>());

// 여러 스레드에서 동시에 접근
new Thread(() -> {
    synchronizedCollection.add("item1");
    synchronizedCollection.add("item2");
}).start();

new Thread(() -> {
    // removeIf 호출 시 ConcurrentModificationException 발생 가능
    synchronizedCollection.removeIf(item -> item.equals("item1"));
}).start();
```

**✅ 자바 플랫폼 라이브러리는 이러한 문제를 예방하기 위한 조치**를 취했다.

**구현한 인터페이스의 디폴트 메서드를 재정의**하고,

**다른 메서드들이 디폴트 메서드를 호출하기 전**에 **필요한 작업을 수행하도록 보장**했다.

❗️하지만 **자바 플랫폼 외부의 제3자 컬렉션 구현체**들은 이러한 언어 수준의 인터페이스 변화를 따라잡을 기회가 없어 **수정이 안되었고**, 일부는 아직도 이전 방식을 유지하고 있다.

**⚠️ 디폴트 메서드는 컴파일이 성공하더라도 기존 구현체에서 런타임 오류를 발생시킬 수 있다.**

→ 기존 인터페이스에 디폴트 메서드를 추가하는 것은 **반드시 필요한 경우가 아니라면 피해야 한다.** 또한, 디폴트 메서드를 추가할 때는 **기존 구현체들과의 충돌 가능성을 신중히 검토**해야 한다.

✅ 반면, **새로운 인터페이스를 설계할 때**는 디폴트 메서드가 매우 유용하다. **표준 메서드 구현을 제공하여 인터페이스를 더 쉽게 구현하고 활용할 수 있기 때문**이다.

**⚠️** 한편, **디폴트 메서드는 인터페이스에서 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도로 사용해서는 안 된다.**

✨ **핵심 정리**

1. **디폴트 메서드라는 도구가 있더라도, 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다. (디폴트 메서드로 기존 인터페이스에 새로운 메서드를 추가하면 치명적인 위험이 동반될 수 있다.)**
2. **새로운 인터페이스를 만들 때는 릴리스 전에 반드시 테스트를 거쳐야 한다. (많은 개발자가 각자의 방식으로 인터페이스를 구현할 것이기 때문)**
3. **인터페이스를 릴리스한 후에도 결함을 수정할 수 있는 경우가 있지만, 절대 그 가능성에 기대서는 안 된다.**

**✅ 그래서 인터페이스를 설계할 때 구현하는 쪽을 고려해야 하는 이유?**

**인터페이스는 한번 공개되면 많은 개발자들이 각자의 방식으로 구현하게 되고, 이후에 인터페이스를 변경하면 기존 구현체들에 심각한 문제가 발생할 수 있기 때문.**

예를 들어 디폴트 메서드를 추가할 때도 기존 구현체들과의 호환성 문제나 동기화 이슈 등이 발생할 수 있어, 처음 설계 단계에서부터 구현하는 쪽의 관점에서 신중하게 고려해야 한다.