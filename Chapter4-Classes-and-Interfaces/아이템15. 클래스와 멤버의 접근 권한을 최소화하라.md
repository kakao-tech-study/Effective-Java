### 아이템15. 클래스와 멤버의 접근 권한을 최소화하라

✅ **어설프게 설계된 컴포넌트, 잘 설계된 컴포넌트**의 가장 큰 차이
→ **클래스 내부 데이터와 내부 구현 정보**를 **외부 컴포넌트**로부터 얼마나 **잘 숨겼는지**

✨ **잘 설계된 컴포넌트: 모든 내부 구현을 완벽히 숨긴다.** (구현과 API 깔끔하게 분리)

정보 은닉, 캡슐화 → 소프트웨어 설계의 근간이 되는 원리

**정보 은닉의 장점**

1. 시스템 개발 속도를 높인다. (여러 컴포넌트를 병렬로 개발 할 수 있기 때문)
2. 시스템 관리 비용을 낮춘다. (각 컴포넌트를 더 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문)
3. 정보 은닉 자체가 성능을 높여주진 않으나, 성능 최적화에 도움을 준다.(완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음, 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있기 때문)
4. 소프트웨어 재사용성을 높인다.(외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문)
5. 큰 시스템을 제작하는 난이도를 낮춰준다. (시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문)

**✅ 자바는 정보 은닉을 위한 다양한 장치를 제공한다**

그 중 접근 제어 메커니즘은 클래스, 인터페이스, 멤버의 접근성을 명시한다.

- private
- protected
- public

이 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심!

⚠️ **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.**

→ (소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야한다.)

**톱레벨 클래스(가장 바깥), 인터페이스**에 부여 가능 접근 수준:

- package-private
- public

public으로 선언 시: 공개 API

package-private로 선언 시: 해당 패키지 안에서만 사용 가능

따라서, 패키지를 외부에서 쓸 이유가 없다면 package-private로 선언

→ API가 아닌 내부 구현이 되어 언제든 수정할 수 있다.

즉, 클라이언트에 아무런 피해 없이 다음 릴리스에서 수정, 교체, 제거할 수 있다.

반면, public으로 선언한다면 API가 되므로 하위 호환을 위해 영원히 관리해줘야만 한다.

한 클래스에서만 사용하는 package-private 톱레벨 클래스나

인터페이스는 이를 사용하는 클래스를 안에

private static으로 중첩 시키면, 바깥 클래스 하나에서만 접근할 수 있다.

중첩시키지 않으면, 같은 패키지의 모든 클래스가 접근할 수 있다.

(private static 으로 하면 더 좋음)

⚠️ **중요!**

**public일 필요가 없는 클래스의 접근 수준을 package-private 톱레벨 클래스로 좁히는일**

public 클래스: 그 패키지의 API

package-private 톱레벨 클래스: 내부 구현에 속함

✅ **멤버(필드, 메서드, 중첩 클래스, 중첩  인터페이스)에 부여할 수 있는 접근 수준**

- private → 멤버를 선언한 톱레벨 클래스에서만 접근
- package-private → 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능
  (접근 제한자 명시하지 않을 시 적용되는 패키지 접근 수준, 단, 인터페이스의 멤버는 기본적으로 public)
- protected → package-private의 접근 범위 포함, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
- public → 모든 곳에서 접근 가능

클래스의 공개 API를 세심히 설계한 후, 그 외의 모든 멤버는 private로 만든다. 그 다음 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에게 한하여 private 제한자를 제거해 package-private 으로 풀어준다.

❗️**권한을 풀어주는 일을 자주 하게 된다면 컴포넌트를 더 분해해야 하는 것은 아닌지 고민해볼것**

private, package-private 멤버는 모두 해당 클래스의 구현에 해당
→ 보통은 공개 API에 영향을 주지 않음

(단, Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수 있다.)

- ❓**Serializable(직렬화)?**

  **자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록**

  객체를 **바이트 스트림으로 변환**하여 **저장**하거나 **네트워크를 통해 전송할 수 있도록 만드는 과정**

  Deserialization(역직렬화)은 반대과정으로, 바이트 스트림을 다시 객체로 복원하는 과정.

  ⚠️ 직렬화 주의점

    1. **객체 의존성**: 직렬화된 객체가 다른 객체를 참조하면 참조된 객체도 함께 직렬화되어야 함
    2. **보안**: 민감한 데이터는 transient로 처리하거나 암호화해서 저장하는 것이 좋음
    3. **성능**: 직렬화는 비교적 무겁고 느리기 때문에 필요한 경우에만 사용하는 것이 좋음
    4. **호환성**: 클래스 구조가 변경되면 이전에 저장한 객체를 복원할 때 호환성 문제가 발생할 수 있음

  쉽게 말하면, **직렬화는 파일에 저장하거나 네트워크로 보내기 위한 ‘포장지’이다.**


**⚠️ public 클래스**에서는 멤버의 접근 수준을 package-private에서 protected로 바꾸는 순간 그 멤버에 접근할 수 있는 대상 범위가 엄청나게 넓어진다.

public 클래스의 protected 멤버는 공개 API이므로 영원히 지원되어야 한다.

→ 쉽게 설명하자면, public 클래스에서 protected 멤버로 선언한 경우, 접근 가능한 대상이 확 늘어나기 때문에 신중하게 다뤄야 한다는 뜻

protected는 같은 패키지에 있는 클래스와 자식 클래스(상속받은 클래스)에서 접근할 수 있도록 허용하는 접근제한자이기 때문

원래 package-private(아무 접근 제한자를 안 붙인 기본 상태)로 멤버를 선언하면, **같은 패키지 안에서만 접근 가능함.**

하지만 protected**로 바꾸면 상속받은 클래스에서도 접근할 수 있는 권한**이 생겨서, **다른 패키지의 자식 클래스도 사용할 수 있게 된다.**

즉, **내부적으로만 쓰려고 했던 코드가 외부에서 활용될 가능성**이 커진다.

예를 들어, 처음엔 내부적으로만 쓰려고 만든 멤버를 protected**로 바꿔 외부에서 접근 가능**하게 했다면,

1. **외부 클래스들이 이 멤버를 의존**하게 될 수 있다.
2. 이후 이 멤버를 수정하거나 삭제하면, **외부 코드가 망가질 위험**이 생긴다.
3. 그래서 이 멤버를 수정하거나 없애지 못하고, **“영원히” 유지해야 하는 부담**이 생긴다.

따라서 protected 멤버의 수는 적을수록 좋다.

🚫 제약사항

**상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다.**

→ 상위클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙

(리스코프 치환 규칙)을 지키기 위해 필요

이 규칙을 어기면 하위 클래스 컴파일할 때 오류가 남.

이때 클래스는 인터페이스가 정의한 모든 메서드를 public으로 선언해야한다.

1. 상위 클래스의 메서드보다 하위 클래스의 오버라이딩 메서드의 **접근 수준이 좁아지면** 제약사항을 어기게 된다. 그래서 자바가 **컴파일 오류**로 막아주는 것
2. 인터페이스의 메서드는 항상 public 이어야 하므로, 이를 구현하는 클래스도 모든 메서드를 public으로 선언해야 한다.

⚠️ 단지 코드를 테스트하려는 목적으로 클래스, 인터페이스, 멤버의 접근 범위를 넓히려 할 때가 있다.

적당한 수준까지는 괜찮다.

public 클래스의 private 멤버를 packaget-private까지 풀어주는 것은 괜찮으나 그 이상은 안된다.

🚫 **public 클래스의 인스턴스는 되도록 public이 아니어야한다.**

public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게된다.(불변식 보장X)

🚫 **public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않음.**

심지어 필드가 final이면서 불변 객체를 참조하더라도 문제는 여전히 남는다. 내부 구현을 바꾸고 싶어도 그 public 필드를 없애는 방식으로는 리팩터링 할 수 없다.

✅ 정적 필드에서도 마찬가지이나, **예외 하나 존재**

해당 클래스가 표현하는 추상 개념을 완성하는 데 필요한 구성요소로써 상수라면 public static final 필드로 공개해도 좋다. 관례상 이런 상수의 이름은 대문자 알파벳으로 쓰며, 각 단어 사이에 밑줄(_)을 넣는다.

ex)

```java
public class Constants {
    public static final int MAX_VALUE = 100; // 상수
    public static final String ERROR_MESSAGE = "An error occurred"; // 상수
    public static final double PI = 3.14159; // 상수
}
```

⚠️ 이런 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야한다.

가변 객체를 참조한다면 final이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다.

다른 객체를 참조하지는 못하지만, 참조된 객체 자체는 수정될 수 있다.

🚫 **클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.**

→ 클라이언트에서 그 배열의 내용을 수정할 수 있게 되기 때문.

ex) 보안 허점이 숨어 있다.

```java
public static final Thing[] VALUES = {...};
```

어떤 IDE가 생성하는 접근자는 private 배열 필드의 참조를 반환하여 이 같은 문제를 똑같이 일으킨다.

✅ **해결책?**

1. 앞 코드의 public 배열을 private로 만들고 public 불변 리스트를 추가 하는 것

   ex)

    ```java
    private static final Thing[] PRIVATE_VALUES = {...};
    public static final List<Thing> VALUES =
    	Collictions.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
    ```

2. 배열을 private로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법(방어적 복사)

   ex)

    ```java
    private static final Thing[] PRIVATE_VALUES = {...};
    public static final Thing[] values() {
    	return PRIVATE_VALUES.clone();
    	}
    ```


클라이언트가 무엇을 원하느냐를 판단해 둘 중 하나를 선택하면 된다.

어느 반환 타임이 더 쓰기 편할지, 성능은 어느 쪽이 나을지 고민해 정해야한다.

- ❓**기준이 뭘까?**

  **첫번째 방법(앞 코드의 public 배열을 private로 만들고 public 불변 리스트를 추가 하는 것)**

  **✅ 장점**

    1. **불변성 보장**

       Collections.unmodifiableList는 리스트 자체를 수정하려고 하면 **UnsupportedOperationException**을 던진다.

       따라서 외부에서 리스트를 수정할 수 없고, 안전하다.

    2. **더 편리한 API 제공**

       List 타입으로 반환하면, **리스트 관련 메서드들(e.g.,** size()**,** contains()**,** forEach()**)을 쉽게 사용할 수 있다.**

       배열은 메서드가 제한적이라, 클라이언트 코드에서 리스트로 변환하는 번거로움을 줄일 수 있다.

    3. **메모리 효율**

       PRIVATE_VALUES 배열을 새로 복사하지 않고 리스트로 래핑만 하기 때문에 **성능적으로 더 효율적**


    ❗️**단점**
    
    1. **배열 수정이 완전히 차단되지는 않음**
        
        unmodifiableList는 리스트를 수정할 수 없게 만들지만, 배열 내부의 개별 객체를 수정할 수 있음.
        
        만약 Thing이 **mutable(가변 객체)**라면, 외부 코드에서 리스트의 요소를 변경할 위험이 있음.
        
    2. **타입 제한**
        
        List를 사용하기 때문에 **클라이언트가 배열을 선호하거나 요구하는 경우 적합하지 않을 수 있음.**
        
        예시로, 클라이언트가 배열 기반의 API를 사용할 때는 추가 변환 작업이 필요할 수도 있음.
        
    
    **❇️ 따라서 선택기준으로는?**
    
    **리스트 관련 작업이 많고 클라이언트가 리스트 타입을 선호**하는 경우.
    
    **성능이 중요한 상황**에서, 배열 복사를 피하고 싶은 경우.
    
    **배열의 불변성을 보장할 필요가 없거나, 배열 요소가 모두 불변 객체일 때.**
    
    예: String처럼 완전히 불변인 객체를 배열로 사용할 때.
    
    **두번째 방법(배열을 private로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법(방어적 복사))**
    
    **✅ 장점**
    
    1. **완벽한 보안**
        
        방어적 복사를 통해 배열의 복사본을 반환하므로, **외부에서 원본 배열을 절대로 수정할 수 없음.**
        
        PRIVATE_VALUES.clone()은 배열 내용을 통째로 복사하므로, **배열의 불변성이 완벽히 보장**.
        
    2. **배열 기반 API에 적합**
        
        배열을 그대로 반환하기 때문에, 클라이언트가 배열 기반의 API를 사용하거나 배열을 직접적으로 다뤄야 할 때 편리함.
        
    
    ❗️**단점**
    
    1. **성능 저하**
        
        매번 배열을 복사하므로, 데이터 크기가 크거나 메서드 호출이 빈번한 경우 성능에 영향을 줄 수 있음.
        
        특히, 배열이 클수록 복사 비용이 크기 때문에 **리소스 효율적이지 않을 수 있음.**
        
    2. **클라이언트 편의성 낮음**
        
        배열은 메서드가 제한적이라, 리스트처럼 다루려면 클라이언트가 직접 변환 작업을 해야 함.
        
        예시로, Arrays.asList() 같은 변환 과정을 추가로 해야 해서 **사용성 측면에서 불편**할 수 있음.
        
    
    ❇️ **따라서 선택기준으로는?**
    
    배열 요소가 **가변 객체**일 경우.
    
    배열에 포함된 객체가 내부 상태를 변경할 수 있다면, 방어적 복사를 통해 원본 배열을 완벽히 보호해야함.
    
    **→ 배열 기반 API와의 호환성이 중요한 경우.**
    
    클라이언트가 배열을 직접 사용하는 코드를 작성해야 하는 상황이라면 배열을 반환하는 게 더 직관적임.
    
    → 데이터 크기가 작아서 **성능이 크게 문제가 되지 않는 경우.**


protected 혹은 public 멤버라도 해당 패키지를 공개하지 않았다면, 모듈 외부에서는 접근할 수 없다.

모듈 안에서는 exports로 선언했는지 여부에 아무런 영향도 받지 않는다.

모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다.

⚠️ **모듈에 적용되는 두 접근 수준은 상당히 주의해서 사용해야한다.**

모듈의 JAR 파일을 자신의 모듈 경로가 아닌 애플리케이션의 클래스패스(classpath)에 두면 그 모듈안의 모든 패키지는 마치 모듈이 없는 것처럼 행동한다.

→ 모듈이 공개 했는지 여부와 상관 X,  public 클래스가 선언한 모든 public 혹은 protected 멤버를 모듈 밖에서도 접근할 수 있게 된다.

새로 등장한 이 접근 수준을 적극 활용한 대표적인 예가 바로 JDK이다.

자바 라이브러리에서 공개하지 않은 패키지들은 해당 모듈 밖에서는 절대로 접근할 수 없다.

✨ **핵심 정리**

프로그램 요소의 접근성은 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하자. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개 되는일이 없도록 해야한다.

public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다. public static final 필드가 참조하는 객체가 불변인지 확인하라.
